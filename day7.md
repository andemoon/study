# day7学习笔记
---
### 今日总结：最后一天了,因为之前学过了mysql，今天就大概复习了一遍，然后继续去学javaweb的东西去了emm


---
### 目录
1. 力扣题
2. mysql
---
#### 力扣题

1332. 删除回文子序列

前几天写过一道回文数和回文链表，总体思路差不多

```java
 public int removePalindromeSub(String s) {
		 
	        if (isPalindrome(s)) {
	            return 1;
	        } else {
	            return 2;
	        }
	    }

	    private boolean isPalindrome(String s) {
	        int l = 0;
	        int r = s.length()-1;
	        while (l <= r) {
	            if (s.charAt(l) != s.charAt(r)) {
	                return false;
	            }
	            l++;
	            r--;
	        }
	        return true;
	    }
```
3. 无重复字符的最长子串

这道题，又学到了一个新的算法：滑动窗口算法。

滑动窗口法，也叫尺取法（可能也不一定相等，大概就是这样 =。=），可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题。由于区间连续，因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。
思路是这样：

1、我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。

2、我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。

3、此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。

4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。

这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。


```java
 public int lengthOfLongestSubstring(String s) {
		 char[] arr=s.toCharArray();
		        int start=0;
		        int end=0;
		        int max=0;
		        Map map=new HashMap();
		        for(int i=0;i<arr.length;i++){
		            end++;
		            if(map.get(arr[i])!=null) {
		                start = Math.max((int) map.get(arr[i]) + 1, start);
		            }
		            max=Math.max(end-start,max);
		            map.put(arr[i],i);
		        }
		        return max;
		    }

```

---
#### mysql

记一些复习时的重点内容

• select语句是检索语句，其用途是从一个或多个表中检索信息，使用select语句需至少给出检索什么以及从什么地方检索两条信息，后才能返回列或者表达式。

• 检索单个列：select xxx from xxx；

• 检索多个列：select xxx，xxx from xxx；

• 检索所有列：select * from xxx；

• 检索不同的行：select distinct xxx from xxx;

○ Distinct 关键词只返回不同的值。

· limit可以限制只返回具体的几行

· 指定要检索的开始行和行数：limit x,y;

---

· 子句：order by xxx; 对输出按字母顺序、数字大小排序。
	
· 对多个列排序：order by xxx,xxx;


· 降序排序：order by xxx desc;

○ desc为降序关键词，asc为升序关键词，默认为asc。

---

	· 检索所需数据需要指定搜索条件(过滤条件）。

	· 在select语句中，根据where子句对数据进行检索，where子句在from子句后给出，且在order by子句前。
	○ 
	○ 格式为：where xxx; 

	· where子句操作符：
	® 等于=
	® 不等于！=或<>
	® 小于和小于等于<,<=
	® 大于和大于等于>,>=
	® 指定两值之间 x between y(包括x和y）

	• 空值检查：where is null;
	○ 表示该项中未储存数据。

	· in操作符：in关键词用来指定条件范围，范围中每个条件都可以匹配。
	○ 格式：where xxx in ()；
	○ in关键词与or关键词相当，但其可以包含其他select语句，且比or语句执行更快。

	· not操作符：否定其之后所有条件。
	○ 格式：where xxx not ——；
	○ 
	○ mysql支持使用not对in、between、exists子句取反。

	· 可以使用and和or组合各个where子句。
	○ and关键词用来匹配所有给出的where子句。
	○ or关键词用来匹配任一给出的where子句。

	· like操作符：使用通配符来匹配包含特定部分的数据。
	○ 格式：where xxx like '   ';

	· 通配符可在任意位置使用且可多次使用。
	® 百分号通配符%表示任一字符出现次数
	
	® 尾空格可能会干扰通配符匹配，如'%a'在a后有空格时，'%a'将不会匹配它们。
	® 下划线通配符_匹配单个字符，与%通配符能匹配0个字符不同，_通配符固定匹配一个字符。


---

	· 正则表达式可以完成较为复杂的匹配，使用regexp关键词构建正则表达式
	○ 格式：where xxx regexp '   ';

	• 正则表达式通配符
	® .表示任意字符
	® |表示or
	® [xyz]表示一组字符，该式表示匹配x或y或z
	® ^表示否，如[^xyz]表示除x,y,z以外的所有字符
	® -表示匹配范围，如[0-9]表示匹配0到9
	® \ \x表示匹配特殊字符，如\\.表示.，\\\表示\
	
	
	

	• 匹配字符类：mysql预先定义的字符集
	® [:alnum:]任意字母数字
	® [:alpha:]任意字母
	® [:blank:]空格和符号
	® [:cntrl:]asc2控制字符
	® [:digit:]任意数字
	® [:graph:]除空格外任意字符
	® [:lower:]任意小写字符
	® [:print:]任意字符
	® [:upper:]任意大写字符
	® [:punct:]除字母数字asc2字符外所有字符

	• 重复字符:表示多次匹配的字符
	® *0个或多个匹配
	® +1个或多个匹配
	® ？0个或1个匹配
	® {n}任意数目匹配
	® {n，}不少于n个数目匹配
	® {n，m}匹配数目范围

	· 定位符：表示匹配特定位置文本
	® ^文本开始
	® ￥文本结尾
	® [[:<:] ]词的开始
	® [[:>:] ]词的结尾

---
	· 使用别名：在拼接字段后可以为新列赋予别名，同时也可以为现有列赋予别名。
	○ 格式：select xxx as yyy;

	• 执行算术计算：计算字段可以对检索出的数据进行算术计算。
	○ 

	· 算术操作符
	® + 加
	® -减
	® *乘
	® /除

---	
• sql支持使用函数处理数据，主要有以下四种函数：文本处理函数、数值函数、日期和时间函数、系统函数。
	

	• 文本处理函数：该类函数用作对数据文本做处理
	○ 

	• 常用文本函数：
	® Left(s,n)返回字符串 s 的前 n 个字符
	
	® Right(s,n)返回串s后的n个字符
	® Length()返回串长度
	® Locate(s,s1)从字符串 s 中获取 s1 的开始位置
	
	® Lower()将串装换为小写
	® Upper()将串转为大写
	® Ltrim()去掉串左边空格
	® Rtrim()去掉串右边空格
	® REPEAT(s,n)将串s重复输出n次
	® SUBSTRING(s, start, length)从字符串 s 的 start 位置截取长度为 length 的子字符串

	• 日期和时间函数：将日期和时间按相应的数据类型和格式排序过滤输出
	○ 日期格式必须使用yyyy-mm-dd
	○ 

	· 数值处理函数：仅用于处理数据

	• 聚集函数：使用聚集函数以汇总数据，其运作于表行上计算和返回单个数值。
	® Avg()返回某列平均值
	avg函数忽略null值
	® Count()返回某列行数
	Count(*)对表中所有行的数目进行统计，包括null
	Count(column)对有特定值的行统计，忽略null
	® Max()返回某列最大值
	® Min()返回某列最小值
	® Sum()返回某列之和
	
	® 对以上5个函数，指定distinct关键词则只统计不同的值，但count（*）不被允许使用该关键词；指定all关键词统计所有值，默认为all，
	® 格式：(distinct xxx);

  ---
  分组数据


	• 分组允许把数据分为多个逻辑组，以便对每个组进行聚集计算。
	○ 分组通过子句group by建立，格式为group by xxx，xxx；
	○ 
	
	○ 
	○ Group by子句可以包含任意数目列，且能对分组嵌套。
	○ 建立分组时，将不能从个别列中取出数据。
	○ Group by子句中只能使用有效的表达式或列名，不能使用别名。
	○ 除聚集函数以外，select中所有列必须在group by子句中给出。
	

	• With rollup 关键词可实现在分组统计数据基础上再进行相同的统计。
	○ 
	○ 其中5即为在分组基础上的统计。

	• 可用coalesce 来设置一个可以取代 NUll 的名称
	○ 格式：select coalesce(a,b,c);
	○ 如果a==null,则选择b；如果b==null,则选择c；如果a!=null,则选择a；如果a b c 都为null ，则返回为null（无意义）。

	· 使用having子句对分组数据过滤，且和where子句类似。
	○ 分组过滤是基于分组聚集，即过滤的条件要以聚集函数为基准
	○ where子句可以和having子句共用，where在数据分组前过滤，having在数据分组后过滤。

---
子查询

	• 子查询指嵌套在其他查询中的查询，子查询总是自内而外的，子查询可以完成比一般查询更为复杂的查询。
	○ 

	• 作为计算字段运用子查询
	○ 
	○ 涉及外部表的查询称为相关子查询，这种查询中每一列需使用完全限定列名
---
联结


	• 联结的创建：规定要联结的所有表以及它们如何关联。
	○ 
	○ 联结要给需要联结的所有表名，此时第一个表中的每一个行将会与第二个表中所有行配对（笛卡尔积），所有在使用where语句过滤后即可得到想要的结果。
	○ 可以使多个表进行联结，但要给出关联每个表的联结条件。
	○ 

	• 笛卡尔积：由没有联结条件的表关系返回的结果为笛卡尔积，检索出的数目将是第一个表行数乘以第二个表行数。

	• 内部联结：基于两个表间外键的联结称为内部联结，也叫等值联结，
	○ 内部联结可以使用from xxx1 inner join xxx2 on yyy；语句，其中xxx1和xxx2为表名，yyy为联结条件。

	• 自联结：通过表别名在单条select语句中

---

插入记录：insert

insert into 表 (列名1,列名2,列名3...) values (值1,值2,值3...)；	//向表中插入某些列

insert into 表 values (值1,值2,值3...);		//向表中插入所有列



列名数与values后面的值的个数相等

列的顺序与插入的值的顺序一致

列名的类型与插入的值要一致
插入值的时候不能超过最大长度

值如果是字符串或者日期需要加引号’’

更新记录：update

---

update 表名 set 字段名=值,字段名=值...;

update 表名 set 字段名=值,字段名=值... where 条件;

列名的类型与修改的值要一致

修改值的时候不能超过最大长度

值如果是字符串或者日期要加’’

---

4.删除记录：delete

delete from 表名 [where 条件];

---

三范式
经过研究和对使用中问题的总结，对于设计数据库提出了一些规范，这些规范被称为范式(Normal Form)
目前有迹可寻的共有8种范式，一般需要遵守3范式即可

第一范式(1NF)：

强调的是列的原则性，即列不能够再分成其他几列。

第二范式(2NF)

首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。

第三范式(3NF)

首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。



	


	


    



	
